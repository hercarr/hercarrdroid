<!DOCTYPE html>
    <!--[if lt IE 8 ]><html class="no-js ie ie7" lang="en"> <![endif]-->
    <!--[if IE 8 ]><html class="no-js ie ie8" lang="en"> <![endif]-->
    <!--[if (gte IE 8)|!(IE)]><!--><html class="no-js" lang="en"> <!--<![endif]-->
    <head>
        <!--- basic page needs -->
        <meta charset="utf-8">
        <title>hercarrdroid</title>
        <meta name="description" content="">
        <meta name="author" content="">
        <!-- mobile specific metas -->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <!-- css -->
        <link rel="stylesheet" href="css/default.css">
        <link rel="stylesheet" href="css/style.css">
        <link rel="stylesheet" href="css/responsive.css">
        <link rel="stylesheet" href="css/animate.css">
        <link href="css/prism.css" rel="stylesheet">
        <link rel="stylesheet" href="css/owl.carousel.css">
        <link rel="stylesheet" href="css/owl.theme.css">
        <!-- script -->
        <script src="js/modernizr.js"></script>
       <!-- favicons -->
        <link rel="shortcut icon" href="images/qacg.ico" >
    </head>
    <body>
        <!-- preloader --> 
        <div id="preloader">
            <div class="loader"></div>    
        </div>
        <!--preloader end-->
        <!-- header section -->
        <header id="home">
            <nav id="m-nav">
                <a class="mobile-btn" href="#m-nav" title="Show navigation">Show navigation</a>
                <a class="mobile-btn" href="#" title="Hide navigation">Hide navigation</a>
                <ul id="nav" class="nav">
                    <li><a href="index.html">Inicio</a></li>
                    <li><a href="session-one.html">Sesi&oacute;n # 1</a></li>
                    <li><a href="session-two.html">Sesi&oacute;n # 2</a></li>
                    <li class="current"><a class="smoothscroll" href="#agenda">Sesi&oacute;n # 3</a></li>
                 </ul>
            </nav> 
            <div class="row banner">
                <div class="banner-text">
                    <h1 class="responsive-headline wow zoomIn">Consumo de un REST API</span></h1>
                    <h3 class="wow fadeInUp">
                        Sesi&oacute;n # 3
                    </h3>
                    <hr />
                    <h3 class="wow fadeInUp">Quality &amp; Knowledge on IT Services</h3>
                    <h3 class="wow fadeInUp">Víctor Hernández</h3>
                    <h3 class="wow fadeInUp">victor.hernandez@qacg.com | hercarr.mx@gmail.com</h3>
                    <h3 class="wow fadeInUp"><span style="font-size: .6em;">Sí lo requieres, descarga la versión del proyecto de la sesión anterior</span></h3>
                    <hr />
                </div>
                <p align="center" style="margin-top: -14px;">                                        
                    <a href="https://github.com/hercarr/hercarrdroid/archive/v1.3.zip" class="button" target="_blank"><i class="fa fa-download"></i> Descargar</a>
                </p>
            </div>
            <p class="scrolldown">
                <a class="smoothscroll" href="#about"><i class="fa fa-angle-double-down"></i></a>
            </p>
            <div class="header-overlay"></div>
            <!-- social section -->
            <div id="social">
                <div class="row social-container">
                    <ul class="social">                       
                       <li><a href="https://twitter.com/hercarrmx" target="_blank"><i class="fa fa-twitter"></i></a></li>
                       <li><a href="https://www.facebook.com/hercarrmx" target="_blank"><i class="fa fa-facebook"></i></a></li>                       
                       <li><a href="https://github.com/hercarr" target="_blank"><i class="fa fa-github"></i></a></li>                       
                    </ul>
                </div
            </div>
            <!-- social end -->
        </header>
        <!-- header end -->
        <!-- section two start -->
        <section id="agenda">           
            <h1 class="section-title wow fadeInDown">REST API</h1>            
            <div class="header-col content-header">
                <h2><span>Consumo de un REST API</span></h2>                
            </div>
            <div class="row education">
                En nuestra aplicación, para realizar la invocación de servicios Web basados en REST utilizaremos <a href="http://square.github.io/retrofit/" target="_blank">retrofit</a>, que es una liberia que nos permite realizar peticiones HTTP en una forma fácil al simplificar las tareas comunes que estan presente en cualquier peticion Web.
                <br />
                Con el uso de retrofit, incorporaremos a nuestro aplicación la funcionalidad de mostrar amigos pero obteniendolos de un recurso Web. Para ello primero configuremos nuestro listado de amigos remotos en forma similar al listado de amigos locales.
                <br />
                1 - Modifiquemos el layout <span>fragment_local_friend_list.xml</span> para incorporar dentro del layout el recycler view & textview requeridos.
                <pre><code class="language-markup"><script type="prism-markup"><FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".fragments.LocalFriendListFragment">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/rvFriends"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:scrollbars="vertical" />

    <TextView
	        android:id="@+id/lblEmptyFriends"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:layout_gravity="center"
	        android:textAppearance="?android:attr/textAppearanceLarge"
	        android:textColor="@color/accent"
	        android:text="@string/msg_empty_friends" />

</FrameLayout>
</script></code></pre>
				2 - Ahora, editemos la clase <span>RemoteFriendListFragment.java</span> para:
				<ul>
				    <li>* Definir las referencias del presenter, recycler view, textview y el adaptador</li>
				    <li>* Obtener las instancias de los objetos antes mencionados</li>
				    <li>* Invocar el método findLocalFriends() del presentador para que temporalmente obtenga el origen de datos de forma local</li>
				    <li>* Implementar la interfaz IFriendsView</li>
				    <li>* Configurar nuestro recycler view</li>
				</ul>
				<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.fragments;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import java.util.List;

import mx.hercarr.hercarrdroid.R;
import mx.hercarr.hercarrdroid.adapters.FriendsAdapter;
import mx.hercarr.hercarrdroid.model.Friend;
import mx.hercarr.hercarrdroid.presenter.FriendsPresenter;
import mx.hercarr.hercarrdroid.util.DividerItemDecoration;
import mx.hercarr.hercarrdroid.view.IFriendsView;

public class LocalFriendListFragment extends Fragment
    implements IFriendsView {

    private FriendsPresenter presenter;

    private RecyclerView rvFriends;
    private TextView lblEmptyFriends;

    private FriendsAdapter adapter;

    public LocalFriendListFragment() {

    }

    public static LocalFriendListFragment newInstance() {
        LocalFriendListFragment fragment = new LocalFriendListFragment();
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_local_friend_list, container, false);
        init(view);
        presenter.findLocalFriends();
        return view;
    }

    @Override
    public void loadFriendList(List<Friend> friends) {
        rvFriends.setVisibility(View.VISIBLE);
        lblEmptyFriends.setVisibility(View.GONE);
        setRecyclerView(friends);
    }

    @Override
    public void showEmptyMessage() {
        rvFriends.setVisibility(View.GONE);
        lblEmptyFriends.setVisibility(View.VISIBLE);
    }

    private void init(View view) {
        presenter = new FriendsPresenter(this);
        rvFriends = (RecyclerView) view.findViewById(R.id.rvFriends);
        lblEmptyFriends = (TextView) view.findViewById(R.id.lblEmptyFriends);
    }

    private void setRecyclerView(List<Friend> friends) {
        adapter = new FriendsAdapter(getActivity(), friends, R.layout.item_view_friend);
        rvFriends.setAdapter(adapter);
        rvFriends.setLayoutManager(new LinearLayoutManager(getActivity()));
        rvFriends.setHasFixedSize(true);
        rvFriends.addItemDecoration(new DividerItemDecoration(getActivity()));
    }

}				
</script></code></pre>
				<br />
				Lo anterior, permitirá mostrar en pantalla la lista de amigos  en forma similar a la consulta de amigos locales, el objetivo de esto es nuevamente revisar los elementos involucrados en la contrucción de un listado. Posteriormente, la lista de amigos se obtendrá de un Web Service.
				<br />
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/1-ws.png" alt=""/>
                </div>
                3 - Ahora, haremos uso del widget CardView para mostrar en una forma diferente cada uno de los elementos del listado, para esto primero es necesario agregar la dependencia en el archivo <span>build.gradle</span>
                <pre><code class="language-java"><script type="prism-java">compile 'com.android.support:cardview-v7:23.1.1'
</script></code></pre>
				4 - Generemos el layout <span>card_view_friend.xml</span> que tendrá una distribuición similar al layout <span>item_view_friend.xml</span> con la diferencia que utilizaremos el widget CardView
				<pre><code class="language-markup"><script type="prism-markup"><?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginTop="@dimen/card_margin"
    android:layout_marginBottom="@dimen/card_margin"
    android:layout_marginLeft="@dimen/list_margin"
    android:layout_marginRight="@dimen/list_margin"
    android:orientation="vertical">

    <android.support.v7.widget.CardView
        xmlns:card_view="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        card_view:cardCornerRadius="@dimen/card_corner_radius"
        card_view:cardElevation="@dimen/card_elevation"
        card_view:cardUseCompatPadding="true">

        <RelativeLayout
		            android:layout_width="match_parent"
		            android:layout_height="match_parent">

            <ImageView
			                android:id="@+id/imgProfile"
			                android:src="@android:drawable/sym_def_app_icon"
			                android:layout_width="64dp"
			                android:layout_height="64dp" />

            <LinearLayout
				                android:layout_width="match_parent"
				                android:layout_height="wrap_content"
				                android:orientation="vertical"
				                android:layout_toRightOf="@+id/imgProfile"
				                android:layout_marginLeft="@dimen/list_margin">

                <TextView
					                    android:id="@+id/lblName"
					                    tools:text="The full name value"
					                    android:layout_width="match_parent"
					                    android:layout_height="wrap_content"
					                    style="@style/list_friend_name" />

                <TextView
					                    android:id="@+id/lblEmail"
					                    tools:text="The email value"
					                    android:layout_width="match_parent"
					                    android:layout_height="wrap_content"
					                    style="@style/list_friend_email" />

                <TextView
					                    android:id="@+id/lblCell"
					                    tools:text="The cell value"
					                    android:layout_width="match_parent"
					                    android:layout_height="wrap_content"
					                    style="@style/list_friend_cell" />

            </LinearLayout>

        </RelativeLayout>

    </android.support.v7.widget.CardView>

</LinearLayout>
</script></code></pre>
				<br />
				Recordemos que en la ingeniería de software la reutilización de código toma un papel muy importante. El requerimiento de mostrar un listado de amigos obtenidos remotamente es similar a la funcionalidad que definimos para mostrar el listado de amigos locales. Por ende, reutilicemos cada una de las clases definidas.
				<br />
				<br />
				5 - Modifiquemos la clase <span>FriendsAdapter.java</span> para que ahora reciba el id del layout a utilizar dentro del recycler view.
				<pre><code class="language-java"><script type="prism-java">    /* more code here */
	
	private final int layoutId;
	
	/* more code here */
	
	public FriendsAdapter(Context context, List<Friend> friends, @LayoutRes int layoutId) {
        this.context = context;
        this.layoutId = layoutId;
        this.friends = friends;
    }

    @Override
    public FriendViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(context).inflate(layoutId, parent, false);
        return new FriendViewHolder(view);
    }

    /* more code here */
</script></code></pre>
				6 - Actualicemos la instancia del adaptador en la clase <span>LocalFriendListFragment.java</span>  para indicar que utilizaremos el layout <span>item_view_friend.xml</span>
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

    private void setRecyclerView(List<Friend> friends) {
        adapter = new FriendsAdapter(getActivity(), friends, R.layout.item_view_friend);
        rvFriends.setAdapter(adapter);
        rvFriends.setLayoutManager(new LinearLayoutManager(getActivity()));
        rvFriends.setHasFixedSize(true);
        rvFriends.addItemDecoration(new DividerItemDecoration(getActivity()));
    }

    /* more code here */
</script></code></pre>
				7 - Actualicemos la instancia del adaptador en la clase <span>RemoteFriendListFragment.java</span> para indicar que utilizaremos el layout <span>card_view_friend.xml</span>
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	private void setRecyclerView(List<Friend> friends) {
        adapter = new FriendsAdapter(getActivity(), friends, R.layout.card_view_friend);
        rvFriends.setAdapter(adapter);
        rvFriends.setLayoutManager(new LinearLayoutManager(getActivity()));
        rvFriends.setHasFixedSize(true);
    }

	/* more code here */
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/2-ws.png" alt=""/>
                </div>
                8 - Ahora, llevemos la reutilización de código a nivel del presentador, para ello refactoricemos la clase <span>FriendsPresenter.java</span> para definir dos métodos que nos permitan obtener el origen de datos de forma local o remoto. Obteniendo como resultado el siguiente contenido:                
                <pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.presenter;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import mx.hercarr.hercarrdroid.model.Friend;
import mx.hercarr.hercarrdroid.rest.RandomUserApi;
import mx.hercarr.hercarrdroid.util.Constants;
import mx.hercarr.hercarrdroid.view.IFriendsView;
import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

public class FriendsPresenter {

    private IFriendsView view;

    public FriendsPresenter(IFriendsView view) {
        this.view = view;
    }

    public void findLocalFriends() {
        List<Friend> friends = new ArrayList<>();

        Friend alberto = new Friend();
        alberto.setFirstName("Alberto");
        alberto.setLastName("Carrasco");
        alberto.setEmail("alberto.carrasco@gmail.com");
        alberto.setCell("5587345678");
        alberto.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/mghoz/128.jpg");
        friends.add(alberto);

        Friend david = new Friend();
        david.setFirstName("David");
        david.setLastName("Torres");
        david.setEmail("david.torres@gmail.com");
        david.setCell("5673342398");
        david.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/sauro/128.jpg");
        friends.add(david);

        Friend fatima = new Friend();
        fatima.setFirstName("Fatima");
        fatima.setLastName("Torruco");
        fatima.setEmail("fatima.torruco@gmail.com");
        fatima.setCell("5598020305");
        fatima.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/brynn/128.jpg");
        friends.add(fatima);

        Friend gerardo = new Friend();
        gerardo.setFirstName("Gerardo");
        gerardo.setLastName("Muñoz");
        gerardo.setEmail("gerardo.muñoz@gmail.com");
        gerardo.setCell("5534245576");
        gerardo.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/rogie/128.jpg");
        friends.add(gerardo);

        Friend lila = new Friend();
        lila.setFirstName("Lila");
        lila.setLastName("Hernández");
        lila.setEmail("lila.hernandez@gmail.com");
        lila.setCell("5512764597");
        lila.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/allisongrayce/128.jpg");
        friends.add(lila);

        Friend noemi = new Friend();
        noemi.setFirstName("Noemi");
        noemi.setLastName("Huerta");
        noemi.setEmail("noemi.huerta@gmail.com");
        noemi.setCell("5598356784");
        noemi.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/jeanniehuang/128.jpg");
        friends.add(noemi);

        Friend monica = new Friend();
        monica.setFirstName("Monica");
        monica.setLastName("Morales");
        monica.setEmail("monica.morales@gmail.com");
        noemi.setCell("5598753245");
        monica.setPicture("https://s3.amazonaws.com/uifaces/faces/twitter/chloepark/128.jpg");
        friends.add(monica);

        view.loadFriendList(friends);
    }

    public void findRemoteFriends() {
        List<Friend> friends = new ArrayList<>();
        if (friends.isEmpty()) {
            view.showEmptyMessage();
        } else {
            view.loadFriendList(friends);
        }
    }

}                
</script></code></pre>				
				9 - Ahora, actualicemos la invocación de los métodos en cada fragmento correspondiente:
				<br />
				<span>LocalFriendListFragment.java</span>
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_local_friend_list, container, false);
        init(view);
        presenter.findLocalFriends();
        return view;
    }

    /* more code here */
</script></code></pre>
				<span>RemoteFriendListFragment.java</span>
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_remote_friend_list, container, false);
        init(view);
        presenter.findRemoteFriends();
        return view;
    }

    /* more code here */
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/3-ws.png" alt=""/>
                </div>
                Como podemos observar el método findRemoteFriends() temporalmente retorna una lista vacia, esto es correcto ya que en los pasos posteriores aquí será donde invoquemos el Web Service.
				<br />				
            </div>
            <div class="header-col content-header">
                <h2><span>Configuración de Retrofit</span></h2>                
            </div>            
            <div class="row education">
            	Los pasos de la sección anterior, nos permitieron que al seleccionar la opción Web Service del Navigation Drawer mostremos en pantalla un listado de amigos cargados localmente. Ahora, llego el momento de obtener a estos amigos mediante la invocación de un Web Service, para ello primero se requiere incorporar retrofit al proyecto así como conocer la respuesta del Web Service.
            	<br />
            	Para obtener los amigos en forma remota, haremos uso de <a href="https://randomuser.me/" target="_blank">randomuser</a>. Este recurso posee una API libre que nos permite obtener de forma aleatoria información de usuarios. Utilizaremos estos datos para convertir los datos de un usuario en los datos de un Friend.
            	<br />
            	Por favor, en nuestro browser realicemos la petición de la siguiente URL <a href="http://api.randomuser.me/?results=50" target="_blank">http://api.randomuser.me/?results=50</a> con el objetivo de conocer el formato de respuesta, el cual utilizaremos más adelante.
            	<br />
            	<br />
            	Ahora realicemos los siguientes pasos para invocar el Web Service y posteriormente mostrar el listado de amigos con la información obtenida.
            	<br />
            	1 - Primero es necesario agregar las siguientes dependencias en el archivo <span>build.gradle</span> para disponer de la libreria en nuestro proyecto
                <pre><code class="language-java"><script type="prism-java">compile 'com.squareup.retrofit2:retrofit:2.0.1'
compile 'com.squareup.okhttp3:okhttp:3.2.0'
</script></code></pre>
				La forma en que retrofit realiza las peticiones a determinado recurso, es mediante la declaración de interfaces en las cuales cada método definido representa una invocación a un recurso u operación del Web Service. Lo que debemos definir son principalente cuatro cosas:
				<ul>
					<li>* El método HTTP por el cual se realizará la petición</li>
					<li>* La URL a la cual hará la petición</li>
					<li>* El tipo de la respuesta </li>
					<li>* Y los parámetros requeridos</li>
				</ul>
				En nuestro ejemplo, la petición la realizaremos mediante el método GET, como tipo de respuesta será propiamente el cuerpo de la petición y en este momento no contamos con algún parametro. Es importante mencionar que la URL que se especifica dentro de la anotación del método seŕa concatenada a una URL base que definiremos posteriormente.
				<br />
				<br />
				2 - Con base a lo anterior, definamos la interfaz <span>FriendsApi.java</span> la cua encapsulará las operaciones a realizar sobre nuestro recurso Friend (para nuestro ejemplo, solo se requiere la busqueda de amigos)
				<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.rest;

import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.GET;

public interface FriendsApi {

    @GET("/?results=50")
    Call<ResponseBody> findFriends();

}
</script></code></pre>
				Comunmente en una aplicación móvil existen diversos recursos, es decir, diversos Web Services en relación a nuestro modelo. Por ello, es una buena práctica contar con una clase de configuración en la cual especifiquemos la configuración básica de retrofit así como definamos cada uno de los servicios a requerir para los diversos recursos.
				<br />
				3 - Para nuestro ejemplo, definamos la interfaz <span>RandomUserApi.java</span> en la cual:
				<ul>
					<li>* Definamos la URL base</li>
					<li>* Configuremos la instancia de retrofit</li>
					<li>* Indiquemos la construcción los servicios necesarios para las peticiones Web</li>
				</ul>
				<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.rest;

import retrofit2.Retrofit;

public class RandomUserApi {

    private static final String URL_BASE = "http://api.randomuser.me";
    private static Retrofit retrofit;
    private static FriendsApi friendsApi;

    private RandomUserApi() {

    }

    static {
        setupRetrofit();
        setupApis();
    }

    private static void setupRetrofit() {
        Retrofit.Builder builder = new Retrofit.Builder()
                .baseUrl(URL_BASE);
        retrofit = builder.build();
    }

    private static void setupApis() {
        friendsApi = retrofit.create(FriendsApi.class);
    }

    public static FriendsApi getFriendsApi() {
        return friendsApi;
    }

}
</script></code></pre>
				4 - Ahora, es tiempo de invocar el API en el metodo findRemoteFriends del presentador. Por favor implementemos el código siguiente, el objetivo es visualizar que la respuesta que recibimos corresponde al json que observamos en el browser al hacer la petición de la URL antes indicada.
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	public void findRemoteFriends() {
        Call<ResponseBody> call = RandomUserApi.getFriendsApi().findFriends();
        call.enqueue(new Callback<ResponseBody>() {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                String json = null;
                try {
                    json = response.body().string();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                Log.d("RETROFIT", json);
            }

            @Override
            public void onFailure(Call<ResponseBody> call, Throwable t) {
                Log.d("RETROFIT", "error!!!");
            }
        });
    }

    /* more code here*/
</script></code></pre>
				5 - Modifiquemos la clase <span>RemoteFriendListFragment.java</span> para llamar a la configuración del recycler view una vez cargue la vista
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_remote_friend_list, container, false);
        init(view);
        setRecyclerView(null);
        presenter.findRemoteFriends();
        return view;
    }

    /* more code here*/
</script></code></pre>
				6 - Modifiquemos la clase <span>FriendsAdapter.java</span> para evitar un crash de la aplicación al intentar mostrar en primera instancia una lista nula (esto debido a que la lista remota se obtendrá una vez se termine la petición HTTP ejecutada en un hilo aparte de la aplicación)
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	public FriendsAdapter(Context context, List<Friend> friends, int layoutId) {
        this.context = context;
        this.layoutId = layoutId;
        if (friends != null)
            this.friends = friends;
        else
            this.friends = new ArrayList<>();
    }

    /* more code here*/
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/4-ws.png" alt=""/>
                </div>
                7 - Ahora, es momento de recuperar la información existente en el json para construir a cada uno de nuestros amigos. Actualicemos la clase <span>FriendsPresenter.java</span> para incorporar un método que nos permita realizar un parser entre la respuesta json obtenida hacia los objetos que requerimos en nuestra lista e invocar este dentro de la respuesta exitosa de la petición http.
                <pre><code class="language-java"><script type="prism-java">    /* more code here */

	public void findRemoteFriends() {
        Call<ResponseBody> call = RandomUserApi.getFriendsApi().findFriends();
        call.enqueue(new Callback<ResponseBody>() {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                view.loadFriendList(parseRandomUsers(response));
            }

            @Override
            public void onFailure(Call<ResponseBody> call, Throwable t) {
                view.showEmptyMessage();
            }
        });
    }

    private List<Friend> parseRandomUsers(Response<ResponseBody> response) {
        String json;
        List<Friend> friends = new ArrayList<>();
        try {
            json = response.body().string();
            JSONObject jsonResponse = new JSONObject(json);
            JSONArray jsonUsers = jsonResponse.getJSONArray(Constants.JsonKeys.RESULTS);
            JSONObject jsonUser;
            Friend friend;
            for (int i = 0; i < jsonUsers.length(); i++) {
                jsonUser = jsonUsers.getJSONObject(i);
                friend = new Friend();
                friend.setFirstName(jsonUser.getJSONObject(Constants.JsonKeys.NAME).getString(Constants.JsonKeys.FIRST));
                friend.setLastName(jsonUser.getJSONObject(Constants.JsonKeys.NAME).getString(Constants.JsonKeys.LAST));
                friend.setEmail(jsonUser.getString(Constants.JsonKeys.EMAIL));
                friend.setCell(jsonUser.getString(Constants.JsonKeys.CELL));
                friend.setPhone(jsonUser.getString(Constants.JsonKeys.PHONE));
                friend.setPicture(jsonUser.getJSONObject(Constants.JsonKeys.PICTURE).getString(Constants.JsonKeys.MEDIUM));
                friends.add(friend);
            }
        } catch (IOException | JSONException e) {
            e.printStackTrace();
        }
        return friends;
    }

    /* more code here*/
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/5-ws.png" alt=""/>
                </div>                
            </div>
            <div class="header-col content-header">
                <h2><span>mostrar / ocultar toolbar</span></h2>
            </div>            
            <div class="row education">
            	Material Design recomienda implementar ciertos comportamientos en nuestra aplicación al momento de realizar scroll sobre listados, estas comportamientos se definen el siguiente <a href="https://www.google.com/design/spec/patterns/scrolling-techniques.html#scrolling-techniques-scrolling" target="_blank">link</a>.
            	<br />
            	Modifiquemos el comportamiento de nuestro toolbar para mostrar u ocultar el mismo cuando el usuario realice scroll sobre la lista de amigos. Para ello se requeire modificar los siguientes dos archivos:
            	<br />
            	<br />
            	1- Modifiquemos la propiedad app:layout_scrollFlags del toolbar definido en el archivo <span>app_bar_main.xml</span>
            	<pre><code class="language-markup"><script type="prism-markup">    <!-- more code here -->

    <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            app:popupTheme="@style/AppTheme.PopupOverlay"
            app:layout_scrollFlags="scroll|enterAlways" />

    <!-- more code here -->
</script></code></pre>
				<br />
            	2 - Definamos el color primario al barra de notificaciones ya que de no hacerlo tendremos una transparencia hacia el toolbar, con lo cual aún será visible para el usuario.<span>values-21/style.xml</span>
            	<pre><code class="language-markup"><script type="prism-markup"><resources>

    <style name="AppTheme.NoActionBar">
		        <item name="windowActionBar">false</item>
		        <item name="windowNoTitle">true</item>
		        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
		        <item name="android:statusBarColor">@android:color/transparent</item>
    	</style>

</resources>
</script></code></pre>
            	<br />
            	<span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/ws/6-ws.png" alt=""/>
                </div>
            </div>
            <div class="header-col content-header">
                <h2><span>ViewPager</span></h2>
            </div>
            <div class="row education">
	            Es momento de mostrar ambos listados en una sola pantalla, para ello haremos uso del widget <a href="http://developer.android.com/training/animation/screen-slide.html" target="_blank">view pager</a> así como de <a href="http://developer.android.com/reference/android/support/design/widget/TabLayout.html" target="_blank">tab layout</a> los cuales en conjunto nos permite implementar la especificación de <a href="https://www.google.com/design/spec/components/tabs.html#" target="_blank">tabs</a> para así mostrar varios fragmentos a la vez separados por paginas, para esto realicemos lo siguiente:
	            <br />
                1 - Generemos el fragmento <span>ViewPagerFragment.java</span> haciendo click en <span>File &rarr; New &rarr; Fragment &rarr; Fragment (Blank)</span> sin seleccionar las opciones <i>Include fragment factory methods</i> e <i>Include interface callbacks</i>. Incorporemos el método newInstance()
				<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.fragments;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.ViewGroup;

import mx.hercarr.hercarrdroid.R;

public class ViewPagerFragment extends Fragment {

    public ViewPagerFragment() {

    }

    public static ViewPagerFragment newInstance() {
        ViewPagerFragment fragment = new ViewPagerFragment();
        return fragment;
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_view_pager, container, false);
    }    

}
</script></code></pre> 
                2 - Actualicemos la clase <span>MainActivity.java</span> actualizando el método <span>onNavigationItemSelected</span> para mostrar el nuevo fragmento al seleccionar la opción view pager.
                <pre><code class="language-java"><script type="prism-java">    /* more code here */

    @Override
    public boolean onNavigationItemSelected(MenuItem item) {
        int id = item.getItemId();
        switch (id)  {
            case R.id.nav_recycler_view:
                loadFragment(LocalFriendListFragment.newInstance());
                break;
            case R.id.nav_web_service:
                loadFragment(RemoteFriendListFragment.newInstance());
                break;
            case R.id.nav_view_pager:
                loadFragment(ViewPagerFragment.newInstance());
                break;
            case R.id.nav_camera:
                break;
            case R.id.nav_map:
                break;
            case R.id.nav_settings:
                break;
            case R.id.nav_logout:
                logout();
                break;
            default:
                break;
        }
        closeDrawer();
        return true;
    }

	/* more code here */
</script></code></pre>
                3 - Modifiquemos el layout <span>app_bar_main.xml</span> para definir un id al widget AppBarLayout
                <pre><code class="language-markup"><script type="prism-markup">    <!-- more code here -->

    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBarLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:theme="@style/AppTheme.AppBarOverlay">

    <!-- more code here -->
</script></code></pre>                 
                4 - Implementemos en la clase <span>ViewPagerFragment.java</span> lo siguiente:
                <ul>
                	<li>* Incorporemos una referencia al widget AppBarLayout</li>
                	<li>* Instanciemos un widget TabLayout para agregarlo a nuestro AppBarLayout </li>
                </ul>
                Obteniendo como resultado lo siguiente:
                <pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.fragments;

import android.os.Bundle;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.TabLayout;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import mx.hercarr.hercarrdroid.R;

public class ViewPagerFragment extends Fragment {

    private AppBarLayout appBarLayout;
    private TabLayout tabLayout;

    public ViewPagerFragment() {

    }

    public static ViewPagerFragment newInstance() {
        ViewPagerFragment fragment = new ViewPagerFragment();
        return fragment;
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        init();
        return inflater.inflate(R.layout.fragment_view_pager, container, false);
    }

    private void init() {
        appBarLayout = (AppBarLayout) getActivity().findViewById(R.id.appBarLayout);
        setTabLayout();
    }

    private void setTabLayout() {
        AppBarLayout.LayoutParams layoutParams = new AppBarLayout.LayoutParams(AppBarLayout.LayoutParams.MATCH_PARENT, AppBarLayout.LayoutParams.WRAP_CONTENT);
        tabLayout = new TabLayout(getActivity());
        tabLayout.setLayoutParams(layoutParams);
        appBarLayout.addView(tabLayout);
    }

}
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/vp/1-vp.png" alt=""/>
                </div>
                5 - Descarguemos las iconos correspondientes a las secciones Recycler View y Web Service utilizadadas en el Navigation Drawer pero en color blanco: <a href="https://design.google.com/icons/#ic_list" target="_blank">list icon</a> & <a href="https://design.google.com/icons/#ic_cloud" target="_blank">cloud icon</a>
                <br />
                6 - Actualicemos el layout <span>fragment_view_pager.xml</span> para definir el view pager
                <pre><code class="language-markup"><script type="prism-markup"><FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context="mx.hercarr.hercarrdroid.fragments.ViewPagerFragment">

    <android.support.v4.view.ViewPager
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"  />

</FrameLayout>
</script></code></pre>
                7 - Actualicemos la clase <span>ViewPagerFragment.java</span> para:
                <ul>
                	<li>* Incorporar la referencia del view pager</li>
                	<li>* Definir la clase interna ViewPagerAdapter la cual administrá los fragmentos a mostrar</li>
                	<li>* Instanciar la clase ViewPagerAdapter especificando los fragmentos requeridos - LocalFriendListFragment & RemoteFriendListFragment</li>
                	<li>* Actualizar el elemento TabLayout indicando que estará configurado mediante el view pager</li>
                	<li>* Configurar los iconos a mostrar en cada uno de los tabs</li>
                	<li>* Remover el tablayout al salir de la opción View Pager</li>
                </ul>
    			<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.fragments;

import android.os.Bundle;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.TabLayout;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.List;

import mx.hercarr.hercarrdroid.R;

public class ViewPagerFragment extends Fragment {

    private AppBarLayout appBarLayout;
    private TabLayout tabLayout;
    private ViewPager viewPager;

    public ViewPagerFragment() {

    }

    public static ViewPagerFragment newInstance() {
        ViewPagerFragment fragment = new ViewPagerFragment();
        return fragment;
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_view_pager, container, false);
        init(view);
        return view;
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        appBarLayout.removeView(tabLayout);
    }

    private void init(View view) {
        appBarLayout = (AppBarLayout) getActivity().findViewById(R.id.appBarLayout);
        viewPager = (ViewPager) view.findViewById(R.id.viewPager);
        setViewPager();
        setTabLayout();
        setIcons();
    }

    public void setViewPager() {
        ViewPagerAdapter adapter = new ViewPagerAdapter(getChildFragmentManager());
        adapter.addFragment(LocalFriendListFragment.newInstance());
        adapter.addFragment(RemoteFriendListFragment.newInstance());
        viewPager.setAdapter(adapter);
    }

    private void setTabLayout() {
        AppBarLayout.LayoutParams layoutParams = new AppBarLayout.LayoutParams(AppBarLayout.LayoutParams.MATCH_PARENT, AppBarLayout.LayoutParams.WRAP_CONTENT);
        tabLayout = new TabLayout(getActivity());
        tabLayout.setLayoutParams(layoutParams);
        tabLayout.setupWithViewPager(viewPager);
        appBarLayout.addView(tabLayout);
    }

    public void setIcons() {
        tabLayout.getTabAt(0).setIcon(R.mipmap.ic_list_white_24dp);
        tabLayout.getTabAt(1).setIcon(R.mipmap.ic_cloud_white_24dp);
    }

    private class ViewPagerAdapter extends FragmentPagerAdapter {

        private List<Fragment> fragments;

        public ViewPagerAdapter(FragmentManager fm) {
            super(fm);
            fragments = new ArrayList<>();
        }

        public void addFragment(Fragment fragment) {
            fragments.add(fragment);
        }

        @Override
        public Fragment getItem(int position) {
            return fragments.get(position);
        }

        @Override
        public int getCount() {
            return fragments.size();
        }

    }

}
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/vp/2-vp.png" alt=""/>
                </div>
            </div>
            <div class="header-col content-header">
                <h2><span>Swipe to refresh</span></h2>
            </div>
            <div class="row education">
            	<a href="http://developer.android.com/training/swipe/add-swipe-interface.html" target="_blank">Swipe to refresh</a> - o pull to refresh como se conoce en otras plataformas - es un gesto aplicado a la interfaz de usuario que sirve para actualizar el contenido de una lista cuando el usuario desliza la lista hacia abajo. En android el componente que nos permite realizar esta operación es <a href="http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html" target="_blank">SwipeRefreshLayout</a>.
            	<br />
            	Para incorporar este elemento a nuestra aplicación, modiquemos la consulta de amigos remotos generarando de forma aleatoria la cantidad de resultados a obtener del Web Service, para ello:
            	<br />
            	1 - Actualicemos la interfaz <span>FriendsApi.java</span> para solicitar en el método findFriends la cantidad de resultados deseados
            	<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.rest;

import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.GET;
import retrofit2.http.Query;

public interface FriendsApi {

    @GET("/")
    Call<ResponseBody> findFriends(@Query("results") int amount);

}
</script></code></pre>
				2 - Actualicemos la clase <span>FriendsPresenter.java</span> para especificar la cantidad de resultados a obtener incorporando un método que nos permita obtener de forma aleatoria la cantidad de amigos a buscar
				<pre><code class="language-java"><script type="prism-java">    /* more code here */

	public void findRemoteFriends() {
        Call<ResponseBody> call = RandomUserApi.getFriendsApi().findFriends(getRandomNumberOfFriends());
        /* more code here */
    }


	private int getRandomNumberOfFriends() {
        int min = 10;
        int max = 100;
        int number = new Random().nextInt((max - min) + 1) + min;
        return number;
    }

	/* more code here */
</script></code></pre>
				3 - Actualicemo el layout <span>fragment_remote_friends_list.xml para incorporar el elemento SwipeRefreshLayout</span>
				el cual debe envolver al recycler view
				<pre><code class="language-markup"><script type="prism-markup">    <!-- more code here -->

	<android.support.v4.widget.SwipeRefreshLayout
        android:id="@+id/srlRemoteFriends"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <android.support.v7.widget.RecyclerView
            android:id="@+id/rvFriends"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:scrollbars="vertical" />

    </android.support.v4.widget.SwipeRefreshLayout>

	<!-- more code here -->
</script></code></pre>
				4 - Actualicemos la clase <span>RemoteFriendListFragment.java</span> para:
				<ul>
					<li>* Incorporar la referencia al SwipeRefreshLayout</li>
					<li>* Configurar el SwipeRefreshLayout para invocar el método findRemoteFriends() del presentador al hacer swipe sobre el listado</li>
					<li>* Configuremos los colores a mostar en el indicador de progreso</li>
					<li>* Actualizar el método loadFriendList para ocultar el indicador de progreso del SwipeRefreshLayout cuando la lista de amigos ha sido cargada nuevamente</li>
				</ul>
				<pre><code class="language-java"><script type="prism-java">package mx.hercarr.hercarrdroid.fragments;

import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v4.widget.SwipeRefreshLayout;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import java.util.List;

import mx.hercarr.hercarrdroid.R;
import mx.hercarr.hercarrdroid.adapters.FriendsAdapter;
import mx.hercarr.hercarrdroid.model.Friend;
import mx.hercarr.hercarrdroid.presenter.FriendsPresenter;
import mx.hercarr.hercarrdroid.view.IFriendsView;

public class RemoteFriendListFragment extends Fragment
    implements IFriendsView {

    private FriendsPresenter presenter;

    private RecyclerView rvFriends;
    private TextView lblEmptyFriends;
    private SwipeRefreshLayout srlRemoteFriends;

    private FriendsAdapter adapter;


    public RemoteFriendListFragment() {

    }

    public static RemoteFriendListFragment newInstance() {
        RemoteFriendListFragment fragment = new RemoteFriendListFragment();
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_remote_friend_list, container, false);
        init(view);
        presenter.findRemoteFriends();
        return view;
    }

    @Override
    public void loadFriendList(List<Friend> friends) {
        rvFriends.setVisibility(View.VISIBLE);
        lblEmptyFriends.setVisibility(View.GONE);
        setRecyclerView(friends);
        if (srlRemoteFriends.isRefreshing()) {
            srlRemoteFriends.setRefreshing(false);
        }
    }

    @Override
    public void showEmptyMessage() {
        rvFriends.setVisibility(View.GONE);
        lblEmptyFriends.setVisibility(View.VISIBLE);
    }

    private void init(View view) {
        presenter = new FriendsPresenter(this);
        rvFriends = (RecyclerView) view.findViewById(R.id.rvFriends);
        lblEmptyFriends = (TextView) view.findViewById(R.id.lblEmptyFriends);
        srlRemoteFriends = (SwipeRefreshLayout) view.findViewById(R.id.srlRemoteFriends);
        setRecyclerView(null);
        setSwipeRefreshLayout();
    }

    private void setRecyclerView(List<Friend> friends) {
        adapter = new FriendsAdapter(getActivity(), friends, R.layout.card_view_friend);
        rvFriends.setAdapter(adapter);
        rvFriends.setLayoutManager(new LinearLayoutManager(getActivity()));
        rvFriends.setHasFixedSize(true);
    }

    private void setSwipeRefreshLayout() {
        srlRemoteFriends.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                presenter.findRemoteFriends();
            }
        });
        srlRemoteFriends.setColorSchemeColors(
                ContextCompat.getColor(getActivity(), R.color.primary_dark),
                ContextCompat.getColor(getActivity(), R.color.accent),
                ContextCompat.getColor(getActivity(), R.color.primary_dark)
        );
    }

}				
</script></code></pre>
				<br />
                <span style="color: #e91e63;">- It's time to run the project & test it-</span>
                <div class="content-picture-container">
                    <img class="content-picture wow zoomIn" src="images/vp/3-vp.png" alt=""/>
                </div>
            </div>
        </section>
        <!-- section two end -->
        <!-- footer -->
        <footer>
            <div class="row">
                <div class="twelve columns">
                    <ul class="social-links">
                        <li><a href="https://twitter.com/hercarrmx" target="_blank"><i class="fa fa-twitter"></i></a></li>
                        <li><a href="https://www.facebook.com/hercarrmx" target="_blank"><i class="fa fa-facebook"></i></a></li>                        
                        <li><a href="https://github.com/hercarr" target="_blank"><i class="fa fa-github"></i></a></li>
                    </ul>
                    <ul class="copyright">
                        <li>hercarr.mx@gmail.com | 2016 | Ciudad de M&eacute;xico</li>
                    </ul>
                </div>
                <div id="go-top"><a class="smoothscroll" title="Back to Top" href="#home"><i class="fa fa-chevron-up"></i></a></div>
            </div>
        </footer>
        <!-- footer end-->
        <!-- java script -->
        <script src="js/jquery-2.1.1.min.js"></script>
        <script src="js/owl.carousel.min.js"></script>
        <script src="js/waypoints.js"></script>
        <script src="js/jquery.fittext.js"></script>
        <script src="js/wow.min.js"></script>
        <script src="js/jquery.nicescroll.min.js"></script>
        <script src="js/prism.js"></script>
        <script src="js/script.js"></script>
    </body>
</html>
